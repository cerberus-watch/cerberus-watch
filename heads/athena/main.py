from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import Optional
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.mount("/static", StaticFiles(directory="heads/athena"), name="static")

@app.get("/")
async def read_index():
    return FileResponse('heads/athena/athena.html')

origins = [
    "http://127.0.0.1:8000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class AnalysisInput(BaseModel):
    name: Optional[str] = None
    phone: Optional[str] = None
    social: Optional[str] = None
    dating_profile: Optional[str] = None

class AthenaAnalyzer:
    def __init__(self, analysis_input: AnalysisInput):
        self.input = analysis_input
        self.search_name = self.input.name.lower() if self.input.name else None

        # Mock database of online profiles with richer background info.
        self.mock_profiles = {
            "john doe": {
                "status": "verified",
                "verified_on": ["LinkedIn", "Twitter"],
                "background_summary": "Public profiles on LinkedIn and Twitter show a consistent work history. No public posts containing aggressive language or concerning affiliations were found."
            },
            "jane smith": {
                "status": "partially_verified",
                "verified_on": ["Facebook"],
                "background_summary": "A single public profile was found on Facebook. The profile is new with limited activity, making a comprehensive background assessment difficult."
            },
        }

    def verify_identity(self):
        """
        **Placeholder Implementation**
        This function simulates identity verification by checking against a mock database.
        """
        print("Step 1: Verifying identity...")
        if not self.search_name:
            return {"status": "unverified", "message": "A name is required for identity verification."}

        profile = self.mock_profiles.get(self.search_name)
        if profile:
            message = f"Identity {profile['status']} for {self.input.name}. Found profiles on: {', '.join(profile['verified_on'])}."
            return {"status": profile['status'], "message": message}
        else:
            message = f"Could not verify identity for {self.input.name}. No public profiles found."
            return {"status": "unverified", "message": message}

    def gather_background_info(self):
        """
        **Placeholder Implementation**
        This function simulates background info gathering by checking against a mock database.
        """
        print("Step 2: Gathering background information...")
        profile = self.mock_profiles.get(self.search_name)
        if profile:
            return {"background_info": profile["background_summary"]}
        else:
            # This case should ideally not be hit if verification runs first.
            return {"background_info": "No background information could be gathered."}

    def analyze_risk(self, background_info):
        """
        **Placeholder Implementation**
        This function simulates a risk analysis based on keywords in the
        background information. A full implementation would use an LLM.
        """
        print("Step 3: Analyzing risk...")

        if "consistent work history" in background_info and "No public posts containing aggressive language" in background_info:
            score = "Good"
            summary = "The individual has a consistent and verifiable public presence with no identifiable risk factors in their public communications."
        elif "limited activity" in background_info:
            score = "Review Recommended"
            summary = "The individual has a limited online presence, which makes a comprehensive safety assessment difficult. Caution is advised."
        else:
            score = "Caution Advised"
            summary = "Could not form a comprehensive safety assessment based on the information available."

        print("Risk analysis complete (placeholder).")
        return {"safety_score": score, "summary": summary}

@app.post("/analyze")
async def analyze(analysis_input: AnalysisInput):
    """
    Runs the full safety analysis pipeline.

    Data Ephemerality: All data is processed in-memory for the duration of this
    request and is not stored or logged. This adheres to the Cerberus
    Ethical Charter's principle of data ephemerality.
    """
    analyzer = AthenaAnalyzer(analysis_input)

    # Step 1: Identity Verification
    identity_result = analyzer.verify_identity()
    if identity_result["status"] == "unverified":
        return {
            "safety_score": "Verification Failed",
            "summary": identity_result["message"]
        }

    # Step 2: Background Information Gathering
    background_info = analyzer.gather_background_info()

    # Step 3: Risk Analysis & Safety Score
    risk_analysis_result = analyzer.analyze_risk(background_info["background_info"])

    # Combine all information for the final summary
    final_summary = (
        f"{identity_result['message']}<br><br>"
        f"{background_info['background_info']}<br><br>"
        f"<b>Risk Analysis:</b> {risk_analysis_result['summary']}"
    )

    return {
        "safety_score": risk_analysis_result["safety_score"],
        "summary": final_summary
    }
